import 'dart:io';

import 'dart:typed_data';

import 'package:image/image.dart' as img;
import 'package:path/path.dart' as path;

import '../models/image.dart';
import '../models/desktop.dart';

import '../common/utils.dart';

import '../src/logger.dart';
import '../src/image.dart';

/// Generates Macos platform-specific code for the native splash screen
///
/// Takes a [config] object containing splash screen configuration,
/// a [flavor] string to support multiple build flavors,
/// and an output [path] to override the default location.
///
/// Returns [true] if generation was successful, [false] otherwise.
Future<bool> generateMacosCode({
  required DesktopSplashConfig config,
  required String flavor,
  required Directory outputDir,
}) async {
  // Validate image file exists
  final imageFile = File(config.imagePath);
  if (!imageFile.existsSync()) {
    logger.e('Image file not found: ${config.imagePath}');
    return false;
  }

  // Load and process the image
  final BGRAImage? imageData = await _loadAndProcessImage(config);
  if (imageData == null) {
    return false;
  }

  // Generate the Swift source file
  return _generateSourceFile(
    outputDir: outputDir.path,
    flavor: flavor,
    config: config,
    imageData: imageData,
  );
}

/// Loads and processes the splash screen image according to configuration
///
/// Returns the processed [BGRAImage] or null if processing failed
Future<BGRAImage?> _loadAndProcessImage(DesktopSplashConfig config) async {
  try {
    return await loadImageAsBGRA(
      config.imagePath,
      blurRadius: config.imageBlurRadius,
      resizeToFit: config.imageScaling,
      imageBorderRadius: config.imageBorderRadius,
      targetWidth: config.imageWidth,
      targetHeight: config.imageHeight,
      backgroundBorderRadius: config.backgroundBorderRadius,
      backgroundColor: config.backgroundColor,
      backgroundWidth: config.backgroundWidth,
      backgroundHeight: config.backgroundHeight,
    );
  } catch (e) {
    logger.e('Failed to load or process the image: $e');
    return null;
  }
}

/// Generates the Swift source file with image data and configuration
///
/// Returns [true] if file generation was successful, [false] otherwise
Future<bool> _generateSourceFile({
  required String outputDir,
  required String flavor,
  required DesktopSplashConfig config,
  required BGRAImage imageData,
}) async {
  final build = flavor.capitalizeFirstLetter();
  final target = 'NativeSplashScreen_$build.swift';

  // Create complete file path using the output directory
  final String outputFilePath = path.join(outputDir, target);

  final outputFile = File(outputFilePath);

  try {
    final buffer = StringBuffer();

    final retinaImageData = _createRetinaImageData(imageData);
    final assets = await _writeImageAssets(
      outputDir: outputDir,
      build: build,
      config: config,
      imageData: imageData,
      retinaImageData: retinaImageData,
    );

    // File header
    buffer.writeln('// Generated file - do not edit');
    buffer.writeln('// Generated by native_splash_screen_cli');
    buffer.writeln('');
    buffer.writeln('import native_splash_screen_macos');
    buffer.writeln('');
    buffer.writeln('');

    // Splash screen configuration
    _writeConfigSection(buffer, config, imageData, build, assets);

    // Write to file
    await outputFile.writeAsString(buffer.toString());
    // logger.success('Generated $target in $outputDir');
    return true;
  } catch (e) {
    logger.e('Failed to generate $target file: $e');
    return false;
  }
}

/// Writes the configuration section of the Swift file
void _writeConfigSection(
  StringBuffer buffer,
  DesktopSplashConfig config,
  BGRAImage imageData,
  String build,
  _MacosImageAssets assets,
) {
  buffer.writeln(
    'class ${build}NativeSplashScreenConfiguration: NativeSplashScreenConfigurationProvider {',
  );
  buffer.writeln('');
  buffer.writeln('    // MARK: - Splash screen properties');
  buffer.writeln('    let windowWidth: Int = ${config.windowWidth}');
  buffer.writeln('    let windowHeight: Int = ${config.windowHeight}');
  buffer.writeln('');

  buffer.writeln('    // MARK: - Window Title');
  buffer.writeln(
    '    let windowTitle: String = "${escapeString(config.windowTitle)}"',
  );
  buffer.writeln('');

  buffer.writeln('    // MARK: - Animation control');
  buffer.writeln('    let withAnimation: Bool = ${config.withAnimation}');
  buffer.writeln('');

  buffer.writeln('    // MARK: - Image dimensions');
  buffer.writeln('    let imageWidth: Int = ${imageData.width}');
  buffer.writeln('    let imageHeight: Int = ${imageData.height}');
  buffer.writeln('');
  buffer.writeln('    // MARK: - Image assets');
  buffer.writeln(
    '    let imageResourceName: String = "${escapeString(assets.resourceName)}"',
  );
  buffer.writeln(
    '    let imageResourceExtension: String = "${escapeString(assets.resourceExtension)}"',
  );

  final retinaName = assets.retinaResourceName;
  if (retinaName != null) {
    buffer.writeln(
      '    let retinaImageResourceName: String? = "${escapeString(retinaName)}"',
    );
  } else {
    buffer.writeln('    let retinaImageResourceName: String? = nil');
  }

  final retinaExtension = assets.retinaResourceExtension;
  if (retinaExtension != null) {
    buffer.writeln(
      '    let retinaImageResourceExtension: String? = "${escapeString(retinaExtension)}"',
    );
  } else {
    buffer.writeln('    let retinaImageResourceExtension: String? = nil');
  }

  buffer.writeln('}');
}

Future<_MacosImageAssets> _writeImageAssets({
  required String outputDir,
  required String build,
  required DesktopSplashConfig config,
  required BGRAImage imageData,
  BGRAImage? retinaImageData,
}) async {
  final normalizedExtension = _normalizeImageExtension(
    config.imageFileExtension,
  );

  final baseName = '${build}_splash';
  final retinaBaseName = '${build}_splash@2x';

  final imageFilePath = path.join(outputDir, '$baseName.$normalizedExtension');
  await File(imageFilePath).writeAsBytes(
    _encodeImage(imageData.original, normalizedExtension),
  );

  String? retinaName;
  String? retinaExtension;
  if (retinaImageData != null) {
    final retinaFilePath =
        path.join(outputDir, '$retinaBaseName.$normalizedExtension');
    await File(retinaFilePath).writeAsBytes(
      _encodeImage(retinaImageData.original, normalizedExtension),
    );

    retinaName = retinaBaseName;
    retinaExtension = normalizedExtension;
  }

  return _MacosImageAssets(
    resourceName: baseName,
    resourceExtension: normalizedExtension,
    retinaResourceName: retinaName,
    retinaResourceExtension: retinaExtension,
  );
}

BGRAImage? _createRetinaImageData(BGRAImage imageData) {
  final original = imageData.original;
  final width = original.width;
  final height = original.height;

  if (width <= 0 || height <= 0) {
    return null;
  }

  final retinaOriginal = img.copyResize(
    original,
    width: width * 2,
    height: height * 2,
    interpolation: img.Interpolation.cubic,
  );

  final bytes = Uint8List(retinaOriginal.width * retinaOriginal.height * 4);
  for (int y = 0; y < retinaOriginal.height; y++) {
    for (int x = 0; x < retinaOriginal.width; x++) {
      final pixel = retinaOriginal.getPixel(x, y);
      final offset = (y * retinaOriginal.width + x) * 4;
      bytes[offset + 0] = pixel.b.toInt();
      bytes[offset + 1] = pixel.g.toInt();
      bytes[offset + 2] = pixel.r.toInt();
      bytes[offset + 3] = pixel.a.toInt();
    }
  }

  return BGRAImage(
    data: bytes,
    width: retinaOriginal.width,
    height: retinaOriginal.height,
    original: retinaOriginal,
  );
}

String _normalizeImageExtension(String extension) {
  final lower = extension.toLowerCase();
  switch (lower) {
    case 'jpg':
    case 'jpeg':
      return 'jpg';
    case 'png':
      return 'png';
    default:
      return 'png';
  }
}

List<int> _encodeImage(img.Image image, String extension) {
  switch (extension) {
    case 'jpg':
      return img.encodeJpg(image, quality: 100);
    default:
      return img.encodePng(image);
  }
}

class _MacosImageAssets {
  final String resourceName;
  final String resourceExtension;
  final String? retinaResourceName;
  final String? retinaResourceExtension;

  const _MacosImageAssets({
    required this.resourceName,
    required this.resourceExtension,
    this.retinaResourceName,
    this.retinaResourceExtension,
  });
}

