import 'dart:io';

import 'dart:math';
import 'dart:typed_data';

import 'package:image/image.dart' as img;
import 'package:path/path.dart' as path;

import '../models/image.dart';
import '../models/desktop.dart';

import '../common/utils.dart';

import '../src/logger.dart';
import '../src/image.dart';

/// Generates Macos platform-specific code for the native splash screen
///
/// Takes a [config] object containing splash screen configuration,
/// a [flavor] string to support multiple build flavors,
/// and an output [path] to override the default location.
///
/// Returns [true] if generation was successful, [false] otherwise.
final Random _pbxIdRandom = Random();

Future<bool> generateMacosCode({
  required DesktopSplashConfig config,
  required String flavor,
  required Directory outputDir,
}) async {
  // Validate image file exists
  final imageFile = File(config.imagePath);
  if (!imageFile.existsSync()) {
    logger.e('Image file not found: ${config.imagePath}');
    return false;
  }

  // Load and process the image
  final BGRAImage? imageData = await _loadAndProcessImage(config);
  if (imageData == null) {
    return false;
  }

  // Generate the Swift source file
  return _generateSourceFile(
    outputDir: outputDir.path,
    flavor: flavor,
    config: config,
    imageData: imageData,
  );
}

/// Loads and processes the splash screen image according to configuration
///
/// Returns the processed [BGRAImage] or null if processing failed
Future<BGRAImage?> _loadAndProcessImage(DesktopSplashConfig config) async {
  try {
    return await loadImageAsBGRA(
      config.imagePath,
      blurRadius: config.imageBlurRadius,
      resizeToFit: config.imageScaling,
      imageBorderRadius: config.imageBorderRadius,
      targetWidth: config.imageWidth,
      targetHeight: config.imageHeight,
      backgroundBorderRadius: config.backgroundBorderRadius,
      backgroundColor: config.backgroundColor,
      backgroundWidth: config.backgroundWidth,
      backgroundHeight: config.backgroundHeight,
    );
  } catch (e) {
    logger.e('Failed to load or process the image: $e');
    return null;
  }
}

/// Generates the Swift source file with image data and configuration
///
/// Returns [true] if file generation was successful, [false] otherwise
Future<bool> _generateSourceFile({
  required String outputDir,
  required String flavor,
  required DesktopSplashConfig config,
  required BGRAImage imageData,
}) async {
  final build = flavor.capitalizeFirstLetter();
  final target = 'NativeSplashScreen_$build.swift';

  // Create complete file path using the output directory
  final String outputFilePath = path.join(outputDir, target);

  final outputFile = File(outputFilePath);

  try {
    final buffer = StringBuffer();

    final retinaImageData = _createRetinaImageData(imageData);
    final assets = await _writeImageAssets(
      outputDir: outputDir,
      build: build,
      config: config,
      imageData: imageData,
      retinaImageData: retinaImageData,
    );
    await _registerAssetsWithXcodeProject(
      runnerDir: outputDir,
      assets: assets.registered,
    );

    // File header
    buffer.writeln('// Generated file - do not edit');
    buffer.writeln('// Generated by native_splash_screen_cli');
    buffer.writeln('');
    buffer.writeln('import native_splash_screen_macos');
    buffer.writeln('');
    buffer.writeln('');

    // Splash screen configuration
    _writeConfigSection(buffer, config, imageData, build, assets);

    // Write to file
    await outputFile.writeAsString(buffer.toString());
    // logger.success('Generated $target in $outputDir');
    return true;
  } catch (e) {
    logger.e('Failed to generate $target file: $e');
    return false;
  }
}

/// Writes the configuration section of the Swift file
void _writeConfigSection(
  StringBuffer buffer,
  DesktopSplashConfig config,
  BGRAImage imageData,
  String build,
  _MacosImageAssets assets,
) {
  buffer.writeln(
    'class ${build}NativeSplashScreenConfiguration: NativeSplashScreenConfigurationProvider {',
  );
  buffer.writeln('');
  buffer.writeln('    // MARK: - Splash screen properties');
  buffer.writeln('    let windowWidth: Int = ${config.windowWidth}');
  buffer.writeln('    let windowHeight: Int = ${config.windowHeight}');
  buffer.writeln('');

  buffer.writeln('    // MARK: - Window Title');
  buffer.writeln(
    '    let windowTitle: String = "${escapeString(config.windowTitle)}"',
  );
  buffer.writeln('');

  buffer.writeln('    // MARK: - Animation control');
  buffer.writeln('    let withAnimation: Bool = ${config.withAnimation}');
  buffer.writeln('');

  buffer.writeln('    // MARK: - Image dimensions');
  buffer.writeln('    let imageWidth: Int = ${imageData.width}');
  buffer.writeln('    let imageHeight: Int = ${imageData.height}');
  buffer.writeln('');
  buffer.writeln('    // MARK: - Image assets');
  buffer.writeln(
    '    let imageResourceName: String = "${escapeString(assets.resourceName)}"',
  );
  buffer.writeln(
    '    let imageResourceExtension: String = "${escapeString(assets.resourceExtension)}"',
  );

  final retinaName = assets.retinaResourceName;
  if (retinaName != null) {
    buffer.writeln(
      '    let retinaImageResourceName: String? = "${escapeString(retinaName)}"',
    );
  } else {
    buffer.writeln('    let retinaImageResourceName: String? = nil');
  }

  final retinaExtension = assets.retinaResourceExtension;
  if (retinaExtension != null) {
    buffer.writeln(
      '    let retinaImageResourceExtension: String? = "${escapeString(retinaExtension)}"',
    );
  } else {
    buffer.writeln('    let retinaImageResourceExtension: String? = nil');
  }

  buffer.writeln('}');
}

Future<_MacosImageAssets> _writeImageAssets({
  required String outputDir,
  required String build,
  required DesktopSplashConfig config,
  required BGRAImage imageData,
  BGRAImage? retinaImageData,
}) async {
  final normalizedExtension = _normalizeImageExtension(
    config.imageFileExtension,
  );

  final baseName = '${build}_splash';
  final retinaBaseName = '${build}_splash@2x';

  final imageFilePath = path.join(outputDir, '$baseName.$normalizedExtension');
  await File(imageFilePath).writeAsBytes(
    _encodeImage(imageData.original, normalizedExtension),
  );

  String? retinaName;
  String? retinaExtension;
  final generatedAssets = <_MacosGeneratedAsset>[
    _MacosGeneratedAsset(
      fileName: '$baseName.$normalizedExtension',
      relativePath:
          path.join('Runner', '$baseName.$normalizedExtension').replaceAll('\\', '/'),
      fileType: _fileTypeForExtension(normalizedExtension),
    ),
  ];
  if (retinaImageData != null) {
    final retinaFilePath =
        path.join(outputDir, '$retinaBaseName.$normalizedExtension');
    await File(retinaFilePath).writeAsBytes(
      _encodeImage(retinaImageData.original, normalizedExtension),
    );

    retinaName = retinaBaseName;
    retinaExtension = normalizedExtension;
    generatedAssets.add(
      _MacosGeneratedAsset(
        fileName: '$retinaBaseName.$normalizedExtension',
        relativePath: path
            .join('Runner', '$retinaBaseName.$normalizedExtension')
            .replaceAll('\\', '/'),
        fileType: _fileTypeForExtension(normalizedExtension),
      ),
    );
  }

  return _MacosImageAssets(
    resourceName: baseName,
    resourceExtension: normalizedExtension,
    retinaResourceName: retinaName,
    retinaResourceExtension: retinaExtension,
    registered: generatedAssets,
  );
}

BGRAImage? _createRetinaImageData(BGRAImage imageData) {
  final original = imageData.original;
  final width = original.width;
  final height = original.height;

  if (width <= 0 || height <= 0) {
    return null;
  }

  final retinaOriginal = img.copyResize(
    original,
    width: width * 2,
    height: height * 2,
    interpolation: img.Interpolation.cubic,
  );

  final bytes = Uint8List(retinaOriginal.width * retinaOriginal.height * 4);
  for (int y = 0; y < retinaOriginal.height; y++) {
    for (int x = 0; x < retinaOriginal.width; x++) {
      final pixel = retinaOriginal.getPixel(x, y);
      final offset = (y * retinaOriginal.width + x) * 4;
      bytes[offset + 0] = pixel.b.toInt();
      bytes[offset + 1] = pixel.g.toInt();
      bytes[offset + 2] = pixel.r.toInt();
      bytes[offset + 3] = pixel.a.toInt();
    }
  }

  return BGRAImage(
    data: bytes,
    width: retinaOriginal.width,
    height: retinaOriginal.height,
    original: retinaOriginal,
  );
}

String _normalizeImageExtension(String extension) {
  final lower = extension.toLowerCase();
  switch (lower) {
    case 'jpg':
    case 'jpeg':
      return 'jpg';
    case 'png':
      return 'png';
    default:
      return 'png';
  }
}

List<int> _encodeImage(img.Image image, String extension) {
  switch (extension) {
    case 'jpg':
      return img.encodeJpg(image, quality: 100);
    default:
      return img.encodePng(image);
  }
}

Future<void> _registerAssetsWithXcodeProject({
  required String runnerDir,
  required List<_MacosGeneratedAsset> assets,
}) async {
  if (assets.isEmpty) {
    return;
  }

  final pbxprojPath = path.normalize(
    path.join(runnerDir, '../Runner.xcodeproj/project.pbxproj'),
  );
  final pbxprojFile = File(pbxprojPath);

  if (!pbxprojFile.existsSync()) {
    logger.w(
      'Unable to locate macOS project file at $pbxprojPath.\n'
      'Add ${assets.map((a) => a.fileName).join(', ')} to the Runner target manually.',
    );
    return;
  }

  var content = await pbxprojFile.readAsString();

  final resourcesGroupId = _findPbxSectionId(
    content,
    sectionType: 'PBXGroup',
    sectionName: 'Resources',
  );
  final resourcesBuildPhaseId = _findPbxSectionId(
    content,
    sectionType: 'PBXResourcesBuildPhase',
    sectionName: 'Resources',
  );

  if (resourcesGroupId == null || resourcesBuildPhaseId == null) {
    logger.w(
      'Unable to update Runner.xcodeproj with generated splash assets.\n'
      'Add ${assets.map((a) => a.fileName).join(', ')} to the Runner target manually.',
    );
    return;
  }

  for (final asset in assets) {
    if (_pbxContainsFileReference(content, asset.relativePath)) {
      continue;
    }

    final fileRefId = _generatePbxId();
    final buildFileId = _generatePbxId();

    final fileRefEntry =
        '                $fileRefId /* ${asset.fileName} */ = {isa = PBXFileReference; lastKnownFileType = ${asset.fileType}; name = ${asset.fileName}; path = ${asset.relativePath}; sourceTree = "<group>"; };\n';
    final buildFileEntry =
        '                $buildFileId /* ${asset.fileName} in Resources */ = {isa = PBXBuildFile; fileRef = $fileRefId /* ${asset.fileName} */; };\n';

    content = _insertBefore(
      content,
      '/* End PBXFileReference section */',
      fileRefEntry,
    );
    content = _insertBefore(
      content,
      '/* End PBXBuildFile section */',
      buildFileEntry,
    );

    content = _addEntryToList(
      content,
      ownerId: resourcesGroupId,
      ownerType: 'PBXGroup',
      listLabel: 'children',
      entry: '                                $fileRefId /* ${asset.fileName} */,\n',
    );
    content = _addEntryToList(
      content,
      ownerId: resourcesBuildPhaseId,
      ownerType: 'PBXResourcesBuildPhase',
      listLabel: 'files',
      entry:
          '                                $buildFileId /* ${asset.fileName} in Resources */,\n',
    );
  }

  await pbxprojFile.writeAsString(content);
}

String? _findPbxSectionId(
  String content, {
  required String sectionType,
  required String sectionName,
}) {
  final pattern = RegExp(
    r'([A-F0-9]{24}) /\* ' +
        RegExp.escape(sectionName) +
        r' \*/ = \{\s+isa = ' +
        sectionType +
        r';',
    multiLine: true,
  );
  final match = pattern.firstMatch(content);
  return match?.group(1);
}

bool _pbxContainsFileReference(String content, String relativePath) {
  final normalizedPath = relativePath.replaceAll('\\', '/');
  return content.contains('path = $normalizedPath;');
}

String _insertBefore(String content, String marker, String insertion) {
  final index = content.indexOf(marker);
  if (index == -1) {
    return content;
  }
  return content.replaceRange(index, index, insertion);
}

String _addEntryToList(
  String content, {
  required String ownerId,
  required String ownerType,
  required String listLabel,
  required String entry,
}) {
  final ownerPattern = RegExp(
    ownerId +
        r' /\* .*? \*/ = \{\s+isa = ' +
        ownerType +
        r';[\s\S]*?' +
        listLabel +
        r' = \(',
  );
  final match = ownerPattern.firstMatch(content);
  if (match == null) {
    return content;
  }

  final listStart = match.end;
  final listEnd = content.indexOf(');', listStart);
  if (listEnd == -1) {
    return content;
  }

  return content.replaceRange(listEnd, listEnd, entry);
}

String _generatePbxId() {
  final buffer = StringBuffer();
  for (var i = 0; i < 12; i++) {
    buffer.write(_pbxIdRandom.nextInt(256).toRadixString(16).padLeft(2, '0'));
  }
  return buffer.toString().toUpperCase();
}

String _fileTypeForExtension(String extension) {
  switch (extension) {
    case 'jpg':
      return 'image.jpeg';
    case 'png':
      return 'image.png';
    default:
      return 'image.png';
  }
}

class _MacosImageAssets {
  final String resourceName;
  final String resourceExtension;
  final String? retinaResourceName;
  final String? retinaResourceExtension;
  final List<_MacosGeneratedAsset> registered;

  const _MacosImageAssets({
    required this.resourceName,
    required this.resourceExtension,
    this.retinaResourceName,
    this.retinaResourceExtension,
    this.registered = const [],
  });
}

class _MacosGeneratedAsset {
  final String fileName;
  final String relativePath;
  final String fileType;

  const _MacosGeneratedAsset({
    required this.fileName,
    required this.relativePath,
    required this.fileType,
  });
}

